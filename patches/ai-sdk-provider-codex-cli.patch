diff --git a/dist/index.cjs b/dist/index.cjs
index 55cf4a22bc67386d3ff619ca4ef554b3ed7d76b0..a74bdd44b4100d0b14c68b5fac1d2134f6692013 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -11,6 +11,10 @@ var zod = require('zod');
 var providerUtils = require('@ai-sdk/provider-utils');
 
 var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
+
+// Windows platform detection for shell mode
+var _isWindows = process.platform === "win32";
+
 // src/codex-cli-provider.ts
 
 // src/logger.ts
@@ -637,7 +641,7 @@ var CodexCliLanguageModel = class {
     if (tempImagePaths.length > 0) {
       args.push("--");
     }
-    args.push(promptText);
+    // Don't push promptText to args - pass via stdin to avoid Windows command line length limits
     return {
       cmd: base.cmd,
       args,
@@ -646,7 +650,8 @@ var CodexCliLanguageModel = class {
       lastMessagePath,
       lastMessageIsTemp,
       schemaPath,
-      tempImagePaths: tempImagePaths.length > 0 ? tempImagePaths : void 0
+      tempImagePaths: tempImagePaths.length > 0 ? tempImagePaths : void 0,
+      promptText
     };
   }
   applyMcpSettings(args, settings) {
@@ -999,7 +1004,7 @@ var CodexCliLanguageModel = class {
     });
     const effectiveSettings = this.mergeSettings(providerOptions);
     const responseFormat = options.responseFormat?.type === "json" ? { type: "json", schema: options.responseFormat.schema } : void 0;
-    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
+    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths, promptText: stdinPrompt } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
     this.logger.debug(
       `[codex-cli] Executing Codex CLI: ${cmd} with ${args.length} arguments, cwd: ${cwd ?? "default"}`
     );
@@ -1007,7 +1012,9 @@ var CodexCliLanguageModel = class {
     let usage = createEmptyCodexUsage();
     const finishReason = mapCodexCliFinishReason(void 0);
     const startTime = Date.now();
-    const child = child_process.spawn(cmd, args, { env, cwd, stdio: ["ignore", "pipe", "pipe"] });
+    const child = child_process.spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"], shell: _isWindows });
+    child.stdin.write(stdinPrompt);
+    child.stdin.end();
     let onAbort;
     if (options.abortSignal) {
       if (options.abortSignal.aborted) {
@@ -1165,14 +1172,16 @@ var CodexCliLanguageModel = class {
     });
     const effectiveSettings = this.mergeSettings(providerOptions);
     const responseFormat = options.responseFormat?.type === "json" ? { type: "json", schema: options.responseFormat.schema } : void 0;
-    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
+    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths, promptText: stdinPrompt } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
     this.logger.debug(
       `[codex-cli] Executing Codex CLI for streaming: ${cmd} with ${args.length} arguments`
     );
     const stream = new ReadableStream({
       start: (controller) => {
         const startTime = Date.now();
-        const child = child_process.spawn(cmd, args, { env, cwd, stdio: ["ignore", "pipe", "pipe"] });
+        const child = child_process.spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"], shell: _isWindows });
+        child.stdin.write(stdinPrompt);
+        child.stdin.end();
         controller.enqueue({ type: "stream-start", warnings });
         let stderr = "";
         let accumulatedText = "";
diff --git a/dist/index.js b/dist/index.js
index 3178db792b8e4b26245ecf2d9c52ab010d0d9cc9..8c32abf85ad0196df30edddc0af0ab6961c5c60b 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,5 +1,5 @@
 import { NoSuchModelError, LoadAPIKeyError, APICallError } from '@ai-sdk/provider';
-import { spawn } from 'child_process';
+import { spawn, execSync, spawnSync } from 'child_process';
 import { randomUUID } from 'crypto';
 import { createRequire } from 'module';
 import { mkdtempSync, writeFileSync, rmSync, readFileSync } from 'fs';
@@ -8,6 +8,40 @@ import { join, dirname } from 'path';
 import { z } from 'zod';
 import { parseProviderOptions, generateId } from '@ai-sdk/provider-utils';
 
+// Windows platform detection for shell mode
+var _isWindows = process.platform === "win32";
+
+// Kill process tree helper
+function killProcessTree(child, signal = 'SIGTERM') {
+  const pid = child.pid;
+  if (!pid) {
+    try { child.kill(signal); } catch {}
+    return;
+  }
+  try {
+    if (_isWindows) {
+      spawnSync('taskkill', ['/pid', String(pid), '/t', '/f'], { stdio: 'ignore' });
+    } else {
+      // Use pgrep to find all descendant processes and kill them
+      try {
+        // Get all child PIDs recursively using pgrep
+        const result = spawnSync('pgrep', ['-P', String(pid)], { encoding: 'utf-8' });
+        if (result.stdout) {
+          const childPids = result.stdout.trim().split('\n').filter(Boolean).map(Number);
+          // Recursively kill children first
+          for (const childPid of childPids) {
+            killProcessTree({ pid: childPid }, signal);
+          }
+        }
+      } catch {}
+      // Kill the main process
+      try {
+        process.kill(pid, signal);
+      } catch {}
+    }
+  } catch {}
+}
+
 // src/codex-cli-provider.ts
 
 // src/logger.ts
@@ -634,7 +668,7 @@ var CodexCliLanguageModel = class {
     if (tempImagePaths.length > 0) {
       args.push("--");
     }
-    args.push(promptText);
+    // Don't push promptText to args - pass via stdin to avoid Windows command line length limits
     return {
       cmd: base.cmd,
       args,
@@ -643,7 +677,8 @@ var CodexCliLanguageModel = class {
       lastMessagePath,
       lastMessageIsTemp,
       schemaPath,
-      tempImagePaths: tempImagePaths.length > 0 ? tempImagePaths : void 0
+      tempImagePaths: tempImagePaths.length > 0 ? tempImagePaths : void 0,
+      promptText
     };
   }
   applyMcpSettings(args, settings) {
@@ -996,7 +1031,7 @@ var CodexCliLanguageModel = class {
     });
     const effectiveSettings = this.mergeSettings(providerOptions);
     const responseFormat = options.responseFormat?.type === "json" ? { type: "json", schema: options.responseFormat.schema } : void 0;
-    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
+    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths, promptText: stdinPrompt } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
     this.logger.debug(
       `[codex-cli] Executing Codex CLI: ${cmd} with ${args.length} arguments, cwd: ${cwd ?? "default"}`
     );
@@ -1004,11 +1039,13 @@ var CodexCliLanguageModel = class {
     let usage = createEmptyCodexUsage();
     const finishReason = mapCodexCliFinishReason(void 0);
     const startTime = Date.now();
-    const child = spawn(cmd, args, { env, cwd, stdio: ["ignore", "pipe", "pipe"] });
+    const child = spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"], shell: _isWindows });
+    child.stdin.write(stdinPrompt);
+    child.stdin.end();
     let onAbort;
     if (options.abortSignal) {
       if (options.abortSignal.aborted) {
-        child.kill("SIGTERM");
+        killProcessTree(child, "SIGTERM");
         if (schemaPath) {
           try {
             const schemaDir = dirname(schemaPath);
@@ -1021,7 +1058,7 @@ var CodexCliLanguageModel = class {
         }
         throw options.abortSignal.reason ?? new Error("Request aborted");
       }
-      onAbort = () => child.kill("SIGTERM");
+      onAbort = () => killProcessTree(child, "SIGTERM");
       options.abortSignal.addEventListener("abort", onAbort, { once: true });
     }
     try {
@@ -1162,14 +1199,16 @@ var CodexCliLanguageModel = class {
     });
     const effectiveSettings = this.mergeSettings(providerOptions);
     const responseFormat = options.responseFormat?.type === "json" ? { type: "json", schema: options.responseFormat.schema } : void 0;
-    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
+    const { cmd, args, env, cwd, lastMessagePath, lastMessageIsTemp, schemaPath, tempImagePaths, promptText: stdinPrompt } = this.buildArgs(promptText, images, responseFormat, effectiveSettings);
     this.logger.debug(
       `[codex-cli] Executing Codex CLI for streaming: ${cmd} with ${args.length} arguments`
     );
     const stream = new ReadableStream({
       start: (controller) => {
         const startTime = Date.now();
-        const child = spawn(cmd, args, { env, cwd, stdio: ["ignore", "pipe", "pipe"] });
+        const child = spawn(cmd, args, { env, cwd, stdio: ["pipe", "pipe", "pipe"], shell: _isWindows });
+        child.stdin.write(stdinPrompt);
+        child.stdin.end();
         controller.enqueue({ type: "stream-start", warnings });
         let stderr = "";
         let accumulatedText = "";
@@ -1257,11 +1296,11 @@ var CodexCliLanguageModel = class {
           }
         };
         const onAbort = () => {
-          child.kill("SIGTERM");
+          killProcessTree(child, "SIGTERM");
         };
         if (options.abortSignal) {
           if (options.abortSignal.aborted) {
-            child.kill("SIGTERM");
+            killProcessTree(child, "SIGTERM");
             cleanupTempFiles();
             controller.error(options.abortSignal.reason ?? new Error("Request aborted"));
             return;
